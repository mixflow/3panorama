// Generated by CoffeeScript 1.12.7

/*
 * A panorama viewer base on three.js.
 * Panarama is a type of image which can be watched in 360 degree horizonally and 180 degree vertically.
 *
 * @license Apache 2.0
 * @author MixFlow
 * @date 2017-08
 */

(function() {
  window.threePanorama = function(settings) {
    var animate, bindMouseControl, camera, container, debugSettings, defaultSettings, init, initRenderer, key, lat, lon, mesh, ref, renderer, scene, update, updateCamera, val;
    defaultSettings = {
      container: document.body,
      image: void 0,
      fov: 65,
      enableDragNewImage: true,
      mouseSensitivity: 0.1,
      lonlat: [0, 0],
      sphere: {
        radius: 500
      },
      debug: {
        imageLoadProgress: false,
        lonlat: false
      }
    };
    settings = settings || {};
    for (key in defaultSettings) {
      val = defaultSettings[key];
      if (!(key in settings)) {
        settings[key] = val;
      }
    }
    if (settings.image == null) {
      throw {
        type: "No image provided.",
        msg: "Please fill panorama image path(string) in the parameter 'image' of settings"
      };
    }
    if (typeof settings.container === "string") {
      container = document.querySelectorAll(setting.container);
    } else {
      container = settings.container;
    }
    lon = settings.lonlat[0];
    lat = settings.lonlat[1];

    /*
     * Initiate the three.js components.
     * Steps:
     *   create a sphere and put panorama on faces inside
     *   create a camera, put it on origin which is also the center of sphere
     *   bind some control:
     *       1. mouse or touch or device orient to control the rotation of camera.
     *   render the scene
     */
    init = function() {
      var camera, geometry, material, mesh, renderer, scene, texture;
      camera = new THREE.PerspectiveCamera(settings.fov, window.innerWidth / window.innerHeight, 1, 1100);
      camera.target = new THREE.Vector3(0, 0, 0);
      geometry = new THREE.SphereBufferGeometry(settings.sphere.radius, 50, 50);
      geometry.scale(-1, 1, 1);
      texture = new THREE.TextureLoader().load(settings.image);
      material = new THREE.MeshBasicMaterial({
        map: texture
      });
      mesh = new THREE.Mesh(geometry, material);
      scene = new THREE.Scene();
      scene.add(mesh);
      renderer = initRenderer();
      container.appendChild(renderer.domElement);
      bindMouseControl(renderer.domElement);
      return {
        camera: camera,
        mesh: mesh,
        scene: scene,
        renderer: renderer
      };
    };
    initRenderer = function() {
      var renderer;
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      return renderer;
    };
    bindMouseControl = function(target) {
      var isUserControling, mouseDown, mouseMove, mouseUp, onMouseDownLat, onMouseDownLon, onMouseDownX, onMouseDownY;
      onMouseDownX = 0;
      onMouseDownY = 0;
      onMouseDownLon = 0;
      onMouseDownLat = 0;
      isUserControling = false;
      mouseDown = function(event) {
        event.preventDefault();
        isUserControling = true;
        onMouseDownX = event.clientX;
        onMouseDownY = event.clientY;
        onMouseDownLon = lon;
        return onMouseDownLat = lat;
      };
      mouseMove = function(event) {
        if (isUserControling === true) {
          lon = (onMouseDownX - event.clientX) * settings.mouseSensitivity + onMouseDownLon;
          lat = (event.clientY - onMouseDownY) * settings.mouseSensitivity + onMouseDownLat;
          if (settings.debug.lonlat) {
            return console.log("longitude: ", lon, "latitude: ", lat);
          }
        }
      };
      mouseUp = function(event) {
        return isUserControling = false;
      };
      target.addEventListener('mousedown', mouseDown, false);
      target.addEventListener('mousemove', mouseMove, false);
      return target.addEventListener('mouseup', mouseUp, false);
    };
    ref = init(), camera = ref.camera, mesh = ref.mesh, scene = ref.scene, renderer = ref.renderer;
    animate = function() {
      requestAnimationFrame(animate);
      update();
    };
    update = function() {
      updateCamera();
      return renderer.render(scene, camera);
    };
    updateCamera = function() {
      var phi, radius, theta, x, y, z;
      lat = Math.max(-85, Math.min(85, lat));
      phi = THREE.Math.degToRad(90 - lat);
      theta = THREE.Math.degToRad(lon);
      radius = settings.sphere.radius;
      x = radius * Math.sin(phi) * Math.cos(theta);
      y = radius * Math.cos(phi);
      z = radius * Math.sin(phi) * Math.sin(theta);
      return camera.lookAt(new THREE.Vector3(x, y, z));
    };
    animate();
    debugSettings = settings.debug;
    return {
      container: container,
      camera: camera,
      mesh: mesh,
      scene: scene,
      renderer: renderer,
      debugSettings: debugSettings
    };
  };

}).call(this);
