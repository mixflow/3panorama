// Generated by CoffeeScript 1.12.7

/*
 * A panorama viewer base on three.js.
 * Panarama is a type of image which can be watched in 360 degree horizonally and 180 degree vertically.
 *
 * @license Apache 2.0
 * @author MixFlow
 * @date 2017-08
 */

(function() {
  window.threePanorama = function(settings) {
    var animate, bindMouseTouchControl, camera, changeFullscreenState, container, debugSettings, defaultSettings, getFullscreenElement, getFullscreenElementHelper, getViewerSize, height, init, initControls, initRenderer, key, lat, lon, mesh, onWindowResize, ref, renderer, scene, toggleTargetFullscreen, update, updateCamera, val, width;
    defaultSettings = {
      container: document.body,
      image: void 0,
      fov: 65,
      useWindowSize: false,

      /*
          If width or height is missing(0), use this alternate ratio to calculate the missing size.
          If you want set specific ratio, please set your container size(width / height = ratio) and `useWindowSize` is false
       */
      alternateRatio: 16 / 9,
      enableDragNewImage: true,
      mouseSensitivity: 0.1,
      lonlat: [0, 0],
      sphere: {
        radius: 500
      },
      debug: {
        imageLoadProgress: false,
        lonlat: false
      }
    };
    settings = settings || {};
    for (key in defaultSettings) {
      val = defaultSettings[key];
      if (!(key in settings)) {
        settings[key] = val;
      }
    }
    if (settings.image == null) {
      throw {
        type: "No image provided.",
        msg: "Please fill panorama image path(string) in the parameter 'image' of settings"
      };
    }
    if (typeof settings.container === "string") {
      container = document.querySelectorAll(settings.container)[0];
    } else {
      container = settings.container;
    }
    lon = settings.lonlat[0];
    lat = settings.lonlat[1];
    width = 0;
    height = 0;
    getViewerSize = function() {
      var rect;
      if (!settings.useWindowSize) {
        rect = container.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
      } else {
        width = window.innerWidth;
      }
      if (!width && !height) {
        throw {
          type: "Lack of Viewer Size.",
          msg: "Viewer width and height are both missing(value is 0), Please check the container size(width and height > 0). Or use window size to set Viewer size by setting `useWindowSize` as `true`"
        };
      } else if (!height) {
        height = width / settings.alternateRatio;
      } else if (!width) {
        width = height * settings.alternateRatio;
      }
      return {
        width: width,
        height: height
      };
    };
    getViewerSize();

    /*
     * Initiate the three.js components.
     * Steps:
     *   create a sphere and put panorama on faces inside
     *   create a camera, put it on origin which is also the center of sphere
     *   bind some control:
     *       1. mouse or touch or device orient to control the rotation of camera.
     *   render the scene
     */
    init = function() {
      var camera, geometry, material, mesh, renderer, scene, texture;
      camera = new THREE.PerspectiveCamera(settings.fov, width / height, 1, 1100);
      camera.target = new THREE.Vector3(0, 0, 0);
      geometry = new THREE.SphereBufferGeometry(settings.sphere.radius, 50, 50);
      geometry.scale(-1, 1, 1);
      texture = new THREE.TextureLoader().load(settings.image);
      material = new THREE.MeshBasicMaterial({
        map: texture
      });
      mesh = new THREE.Mesh(geometry, material);
      scene = new THREE.Scene();
      scene.add(mesh);
      renderer = initRenderer();
      container.appendChild(renderer.domElement);
      bindMouseTouchControl(renderer.domElement);
      initControls(container);
      window.addEventListener("resize", onWindowResize, false);
      return {
        camera: camera,
        mesh: mesh,
        scene: scene,
        renderer: renderer
      };
    };
    initRenderer = function() {
      var renderer;
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);
      return renderer;
    };
    bindMouseTouchControl = function(target) {
      var controlEnd, controlMoveHelper, controlStartHelper, controlStartLat, controlStartLon, controlStartX, controlStartY, isUserControling, mouseDownHandle, mouseMoveHandle, mouseUpHandle, touchEndHandle, touchMoveHandle, touchStartHandle;
      controlStartX = 0;
      controlStartY = 0;
      controlStartLon = 0;
      controlStartLat = 0;
      isUserControling = false;
      controlStartHelper = function(isTouch) {
        return function(event) {
          event.preventDefault();
          isUserControling = true;
          controlStartX = !isTouch ? event.clientX : event.changedTouches[0].clientX;
          controlStartY = !isTouch ? event.clientY : event.changedTouches[0].clientY;
          controlStartLon = lon;
          return controlStartLat = lat;
        };
      };
      controlMoveHelper = function(isTouch) {
        return function(event) {
          var sensitivity, x, y;
          if (isUserControling === true) {
            x = !isTouch ? event.clientX : event.changedTouches[0].clientX;
            y = !isTouch ? event.clientY : event.changedTouches[0].clientY;
            sensitivity = settings.mouseSensitivity;
            lon = (controlStartX - x) * sensitivity + controlStartLon;
            lat = (y - controlStartY) * sensitivity + controlStartLat;
            if (settings.debug.lonlat) {
              return console.log("longitude: ", lon, "latitude: ", lat);
            }
          }
        };
      };
      controlEnd = function(event) {
        return isUserControling = false;
      };
      mouseDownHandle = controlStartHelper(false);
      mouseMoveHandle = controlMoveHelper(false);
      mouseUpHandle = controlEnd;
      target.addEventListener('mousedown', mouseDownHandle, false);
      target.addEventListener('mousemove', mouseMoveHandle, false);
      target.addEventListener('mouseup', mouseUpHandle, false);
      touchStartHandle = controlStartHelper(true);
      touchMoveHandle = controlMoveHelper(true);
      touchEndHandle = controlEnd;
      target.addEventListener("touchstart", touchStartHandle, false);
      target.addEventListener("touchmove", touchMoveHandle, false);
      return target.addEventListener("touchend", touchEndHandle, false);
    };
    getFullscreenElementHelper = function(container) {
      if (container == null) {
        container = document;
      }
      return function() {
        return container.fullscreenElement || container.webkitFullscreenElement || container.mozFullScreenElement || container.msFullscreenElement;
      };
    };
    getFullscreenElement = getFullscreenElementHelper();
    toggleTargetFullscreen = function(target) {

      /*
          If no fullscreen element, the `target` enters fullscree.
          Otherwise fullscreen element exit fullscreen.
          Both trigge the `fullscreenchange` event.
       */
      if (getFullscreenElement()) {
        if (document.exitFullscreen) {
          return document.exitFullscreen();
        } else if (document.msExitFullscreen) {
          return document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          return document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          return document.webkitExitFullscreen();
        } else {
          return console.log("The bowser doesn't support fullscreen mode");
        }
      } else {
        if (document.documentElement.requestFullscreen) {
          return target.requestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
          return target.msRequestFullscreen();
        } else if (document.documentElement.mozRequestFullScreen) {
          return target.mozRequestFullScreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          return target.webkitRequestFullscreen();
        } else {
          return console.log("The bowser doesn't support fullscreen mode");
        }
      }
    };
    changeFullscreenState = function(target) {

      /*
          the actual behavior when fullscreen state is changed.
       */
      var clazz, fullscreenElement;
      fullscreenElement = getFullscreenElement();
      clazz = "fullscreen-mode";
      if ((fullscreenElement != null)) {
        target.className += " " + clazz;
        target.style.width = "100vw";
        target.style.height = "100vh";
        target.style["max-width"] = "unset";
        target.style["max-height"] = "unset";
      } else {
        target.className = target.className.replace(new RegExp('(\\s|^)' + clazz + '(\\s|$)'), '');
        target.style.width = null;
        target.style.height = null;
        target.style["max-width"] = null;
        target.style["max-height"] = null;
      }
      return onWindowResize();
    };
    initControls = function(container) {
      var controls, fullscreen;
      controls = document.createElement("div");
      controls.className = "3panorama-controls";
      controls.style.position = "absolute";
      controls.style.bottom = 0;
      controls.style.width = "100%";
      controls.style.height = "3.5em";
      controls.style["min-height"] = "32px";
      fullscreen = document.createElement("img");
      fullscreen.src = "data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAzMjAgMzIwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMjAgMzIwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjI0cHgiIGhlaWdodD0iMjRweCI+CjxnIGlkPSJYTUxJRF8xMDVfIj4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBwb2ludHM9IjEyNS4wMDcsMTgwLjg0OSAyMCwyODUuODU3IDIwLDIwMy40MDEgMCwyMDMuNDAxIDAsMzIwIDExNi41OTksMzIwIDExNi41OTksMzAwIDM0LjE0MiwzMDAgMTM5LjE1LDE5NC45OTIgICAgICAgICAiIGZpbGw9IiNGRkZGRkYiLz4KCQkJPHBvbHlnb24gcG9pbnRzPSIyMDMuNDAxLDAgMjAzLjQwMSwyMCAyODUuODU1LDIwIDE4MC44NSwxMjUuMDA1IDE5NC45OTMsMTM5LjE0OCAzMDAsMzQuMTQgMzAwLDExNi41OTkgMzIwLDExNi41OTkgMzIwLDAgICAgICAgICAiIGZpbGw9IiNGRkZGRkYiLz4KCQkJPHBvbHlnb24gcG9pbnRzPSIyMCwzNC4xNDIgMTI1LjAwNiwxMzkuMTQ4IDEzOS4xNDksMTI1LjAwNiAzNC4xNDMsMjAgMTE2LjU5OSwyMCAxMTYuNTk5LDAgMCwwIDAsMTE2LjU5OSAyMCwxMTYuNTk5ICAgICIgZmlsbD0iI0ZGRkZGRiIvPgoJCQk8cG9seWdvbiBwb2ludHM9IjMwMCwyODUuODU1IDE5NC45OTQsMTgwLjg0OSAxODAuODUxLDE5NC45OTEgMjg1Ljg2LDMwMCAyMDMuNDAxLDMwMCAyMDMuNDAxLDMyMCAzMjAsMzIwIDMyMCwyMDMuNDAxICAgICAgMzAwLDIwMy40MDEgICAgIiBmaWxsPSIjRkZGRkZGIi8+CgkJPC9nPgoJPC9nPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+Cjwvc3ZnPgo=";
      fullscreen.style.margin = "0.3em";
      fullscreen.style.height = "75%";
      fullscreen.style["min-height"] = "24px";
      fullscreen.addEventListener("click", function() {
        return toggleTargetFullscreen(container);
      }, false);
      document.addEventListener("webkitfullscreenchange", function() {
        return changeFullscreenState(container);
      }, false);
      document.addEventListener("mozfullscreenchange ", function() {
        return changeFullscreenState(container);
      }, false);
      document.addEventListener("msfullscreenchange ", function() {
        return changeFullscreenState(container);
      }, false);
      document.addEventListener("fullscreenchange ", function() {
        return changeFullscreenState(container);
      }, false);
      controls.appendChild(fullscreen);
      return container.appendChild(controls);
    };
    onWindowResize = function(event) {
      getViewerSize();
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      return renderer.setSize(width, height);
    };
    ref = init(), camera = ref.camera, mesh = ref.mesh, scene = ref.scene, renderer = ref.renderer;
    animate = function() {
      requestAnimationFrame(animate);
      update();
    };
    update = function() {
      updateCamera();
      return renderer.render(scene, camera);
    };
    updateCamera = function() {
      var phi, radius, theta, x, y, z;
      lat = Math.max(-85, Math.min(85, lat));
      phi = THREE.Math.degToRad(90 - lat);
      theta = THREE.Math.degToRad(lon);
      radius = settings.sphere.radius;
      x = radius * Math.sin(phi) * Math.cos(theta);
      y = radius * Math.cos(phi);
      z = radius * Math.sin(phi) * Math.sin(theta);
      return camera.lookAt(new THREE.Vector3(x, y, z));
    };
    animate();
    debugSettings = settings.debug;
    return {
      container: container,
      camera: camera,
      mesh: mesh,
      scene: scene,
      renderer: renderer,
      debugSettings: debugSettings
    };
  };

}).call(this);
