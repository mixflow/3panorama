// Generated by CoffeeScript 1.12.7

/*
 * A panorama viewer base on three.js.
 * Panarama is a type of image which can be watched in 360 degree horizonally and 180 degree vertically.
 *
 * @license Apache 2.0
 * @author MixFlow
 * @date 2017-08
 */

(function() {
  var slice = [].slice;

  window.threePanorama = function(settings) {
    var animate, bindMouseTouchControl, camera, changeFullscreenState, container, debugSettings, defaultSettings, getFullscreenElement, getFullscreenElementHelper, getViewerSize, height, init, initControls, initRenderer, key, lat, lon, mesh, onWindowResize, records, ref, renderer, requestAndExitFullscreenHelper, scene, toggleTargetFullscreen, update, updateCamera, util, val, width;
    defaultSettings = {
      container: document.body,
      image: void 0,
      fov: 65,
      canUseWindowSize: false,

      /*
          If width or height is missing(0), use this alternate ratio to calculate the missing size.
          If you want set specific ratio, please set your container size(width / height = ratio) and `canUseWindowSize` is false
       */
      alternateRatio: 16 / 9,

      /*
          recommend to set `true`, if you don't set container width and height.
          Prevent the size of the container and renderer growing when window resizes(fire `onWindowResize` event).
          Record width and height data, next time the container width is some record again, use the correlative height.
       */
      canKeepInitalSize: true,
      enableDragNewImage: true,
      mouseSensitivity: 0.1,
      lonlat: [0, 0],
      sphere: {
        radius: 500
      },
      debug: {
        imageLoadProgress: false,
        lonlat: false,
        cameraSize: false
      }
    };
    settings = settings || {};
    for (key in defaultSettings) {
      val = defaultSettings[key];
      if (!(key in settings)) {
        settings[key] = val;
      }
    }
    if (settings.image == null) {
      throw {
        type: "No image provided.",
        msg: "Please fill panorama image path(string) in the parameter 'image' of settings"
      };
    }
    if (typeof settings.container === "string") {
      container = document.querySelectorAll(settings.container)[0];
    } else {
      container = settings.container;
    }
    lon = settings.lonlat[0];
    lat = settings.lonlat[1];
    width = 0;
    height = 0;
    records = {};
    getViewerSize = function(canKeepInitalSize) {
      var rect;
      if (canKeepInitalSize == null) {
        canKeepInitalSize = settings.canKeepInitalSize;
      }
      if (!settings.canUseWindowSize) {
        rect = container.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
      } else {
        width = window.innerWidth;
        height = window.innerHeight;
      }
      if (!width && !height) {
        throw {
          type: "Lack of Viewer Size.",
          msg: "Viewer width and height are both missing(value is 0), Please check the container size(width and height > 0). Or use window size to set Viewer size by setting `canUseWindowSize` as `true`"
        };
      } else if (!height) {
        height = width / settings.alternateRatio;
      } else if (!width) {
        width = height * settings.alternateRatio;
      }
      if (canKeepInitalSize === true) {
        if (!(width in records)) {
          records[width] = height;
        } else {
          height = records[width];
        }
      }
      if (settings.debug.cameraSize) {
        console.log("current camera size:", width, height);
      }
      return {
        width: width,
        height: height
      };
    };
    getViewerSize();
    util = (function() {
      var handler, wrapperGenerator;
      handler = {
        addClass: function(domel, clazz) {
          return domel.className += " " + clazz;
        },
        removeClass: function(domel, clazz) {
          return domel.className = domel.className.replace(new RegExp('(\\s|^)' + clazz + '(\\s|$)'), '');
        },
        on: function(domel, event, callback, useCapture) {
          var evt, evts, i, len, results;
          if (useCapture == null) {
            useCapture = false;
          }
          evts = event.split(" ");
          results = [];
          for (i = 0, len = evts.length; i < len; i++) {
            evt = evts[i];
            results.push(domel.addEventListener(evt, callback, useCapture));
          }
          return results;
        }
      };
      wrapperGenerator = function(wrapper) {
        var fn, method, methodHelper;
        methodHelper = function(fn) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            fn.apply(null, [wrapper.domel].concat(slice.call(args)));
            return wrapper;
          };
        };
        for (method in handler) {
          fn = handler[method];
          wrapper[method] = methodHelper(fn);
        }
        return wrapper;
      };
      return function(el) {
        var wrapper;
        if (el != null) {
          wrapper = {
            domel: el
          };
          return wrapperGenerator(wrapper);
        } else {
          return handler;
        }
      };
    })();

    /*
     * Initiate the three.js components.
     * Steps:
     *   create a sphere and put panorama on faces inside
     *   create a camera, put it on origin which is also the center of sphere
     *   bind some control:
     *       1. mouse or touch or device orient to control the rotation of camera.
     *   render the scene
     */
    init = function() {
      var camera, geometry, material, mesh, renderer, scene, texture;
      camera = new THREE.PerspectiveCamera(settings.fov, width / height, 1, 1100);
      camera.target = new THREE.Vector3(0, 0, 0);
      geometry = new THREE.SphereBufferGeometry(settings.sphere.radius, 50, 50);
      geometry.scale(-1, 1, 1);
      texture = new THREE.TextureLoader().load(settings.image);
      material = new THREE.MeshBasicMaterial({
        map: texture
      });
      mesh = new THREE.Mesh(geometry, material);
      scene = new THREE.Scene();
      scene.add(mesh);
      renderer = initRenderer();
      container.appendChild(renderer.domElement);
      bindMouseTouchControl(renderer.domElement);
      initControls(container);
      util(window).on("resize", onWindowResize, false);
      return {
        camera: camera,
        mesh: mesh,
        scene: scene,
        renderer: renderer
      };
    };
    initRenderer = function() {
      var renderer;
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);
      return renderer;
    };
    bindMouseTouchControl = function(target) {
      var controlEnd, controlMoveHelper, controlStartHelper, controlStartLat, controlStartLon, controlStartX, controlStartY, isUserControling, mouseDownHandle, mouseMoveHandle, mouseUpHandle, targetUtil, touchEndHandle, touchMoveHandle, touchStartHandle;
      controlStartX = 0;
      controlStartY = 0;
      controlStartLon = 0;
      controlStartLat = 0;
      isUserControling = false;
      controlStartHelper = function(isTouch) {
        return function(event) {
          event.preventDefault();
          isUserControling = true;
          controlStartX = !isTouch ? event.clientX : event.changedTouches[0].clientX;
          controlStartY = !isTouch ? event.clientY : event.changedTouches[0].clientY;
          controlStartLon = lon;
          return controlStartLat = lat;
        };
      };
      controlMoveHelper = function(isTouch) {
        return function(event) {
          var sensitivity, x, y;
          if (isUserControling === true) {
            x = !isTouch ? event.clientX : event.changedTouches[0].clientX;
            y = !isTouch ? event.clientY : event.changedTouches[0].clientY;
            sensitivity = settings.mouseSensitivity;
            lon = (controlStartX - x) * sensitivity + controlStartLon;
            lat = (y - controlStartY) * sensitivity + controlStartLat;
            if (settings.debug.lonlat) {
              return console.log("longitude: ", lon, "latitude: ", lat);
            }
          }
        };
      };
      controlEnd = function(event) {
        return isUserControling = false;
      };
      mouseDownHandle = controlStartHelper(false);
      mouseMoveHandle = controlMoveHelper(false);
      mouseUpHandle = controlEnd;
      targetUtil = util(target);
      targetUtil.on('mousedown', mouseDownHandle, false).on('mousemove', mouseMoveHandle, false).on('mouseup', mouseUpHandle, false);
      touchStartHandle = controlStartHelper(true);
      touchMoveHandle = controlMoveHelper(true);
      touchEndHandle = controlEnd;
      return targetUtil.on("touchstart", touchStartHandle, false).on("touchmove", touchMoveHandle, false).on("touchend", touchEndHandle, false);
    };
    getFullscreenElementHelper = function(container) {
      if (container == null) {
        container = document;
      }
      return function() {
        return container.fullscreenElement || container.webkitFullscreenElement || container.mozFullScreenElement || container.msFullscreenElement;
      };
    };
    getFullscreenElement = getFullscreenElementHelper();
    requestAndExitFullscreenHelper = function() {

      /*
          The helper function to create the `exitFullscreen` and `requestFullscreen`
          callback function.
          There is no need for checking different broswer methods when
          the fullscreen is toggled every time.
       */
      var exitFn, requestFn;
      if (document.exitFullscreen) {

        /*
            `exitFn = document.exitFullscreen` not work
            alternate way: `exitFn = document.exitFullscreen.bind(document)`  (es5)
         */
        exitFn = function() {
          return document.exitFullscreen();
        };
        requestFn = function(target) {
          return target.requestFullscreen();
        };
      } else if (document.msExitFullscreen) {
        exitFn = function() {
          return document.msExitFullscreen();
        };
        requestFn = function(target) {
          return target.msRequestFullscreen();
        };
      } else if (document.mozCancelFullScreen) {
        exitFn = function() {
          return document.mozCancelFullScreen();
        };
        requestFn = function(target) {
          return target.mozRequestFullscreen();
        };
      } else if (document.webkitExitFullscreen) {
        exitFn = function() {
          return document.webkitExitFullscreen();
        };
        requestFn = function(target) {
          return target.webkitRequestFullscreen();
        };
      } else {
        exitFn = function() {
          return console.log("The bowser doesn't support fullscreen mode");
        };
        requestFn = exitFn;
      }
      return {
        request: requestFn,
        exit: exitFn
      };
    };
    toggleTargetFullscreen = (function() {
      var exit, ref, request;
      ref = requestAndExitFullscreenHelper(), request = ref.request, exit = ref.exit;
      return function(target) {

        /*
            If no fullscreen element, the `target` enters fullscree.
            Otherwise fullscreen element exit fullscreen.
            Both trigge the `fullscreenchange` event.
         */
        if (getFullscreenElement()) {
          return exit();
        } else {
          return request(target);
        }
      };
    })();
    changeFullscreenState = function(target) {

      /*
          the actual behavior when fullscreen state is changed.
       */
      var clazz, fullscreenElement, targetUtil;
      fullscreenElement = getFullscreenElement();
      clazz = "fullscreen-mode";
      targetUtil = util(target);
      if ((fullscreenElement != null)) {
        targetUtil.addClass(clazz);
        target.style.width = "100vw";
        target.style.height = "100vh";
        target.style["max-width"] = "unset";
        target.style["max-height"] = "unset";
      } else {
        targetUtil.removeClass(clazz);
        target.style.width = null;
        target.style.height = null;
        target.style["max-width"] = null;
        target.style["max-height"] = null;
      }
      return onWindowResize();
    };
    initControls = function(container) {
      var controls, fullscreen, fullscreenUtil;
      controls = document.createElement("div");
      controls.className = "3panorama-controls";
      controls.style.position = "absolute";
      controls.style.bottom = 0;
      controls.style.width = "100%";
      controls.style.height = "3.5em";
      controls.style["min-height"] = "32px";
      fullscreen = document.createElement("img");
      fullscreenUtil = util(fullscreen);
      fullscreen.src = "data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAzMjAgMzIwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMjAgMzIwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjI0cHgiIGhlaWdodD0iMjRweCI+CjxnIGlkPSJYTUxJRF8xMDVfIj4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBwb2ludHM9IjEyNS4wMDcsMTgwLjg0OSAyMCwyODUuODU3IDIwLDIwMy40MDEgMCwyMDMuNDAxIDAsMzIwIDExNi41OTksMzIwIDExNi41OTksMzAwIDM0LjE0MiwzMDAgMTM5LjE1LDE5NC45OTIgICAgICAgICAiIGZpbGw9IiNGRkZGRkYiLz4KCQkJPHBvbHlnb24gcG9pbnRzPSIyMDMuNDAxLDAgMjAzLjQwMSwyMCAyODUuODU1LDIwIDE4MC44NSwxMjUuMDA1IDE5NC45OTMsMTM5LjE0OCAzMDAsMzQuMTQgMzAwLDExNi41OTkgMzIwLDExNi41OTkgMzIwLDAgICAgICAgICAiIGZpbGw9IiNGRkZGRkYiLz4KCQkJPHBvbHlnb24gcG9pbnRzPSIyMCwzNC4xNDIgMTI1LjAwNiwxMzkuMTQ4IDEzOS4xNDksMTI1LjAwNiAzNC4xNDMsMjAgMTE2LjU5OSwyMCAxMTYuNTk5LDAgMCwwIDAsMTE2LjU5OSAyMCwxMTYuNTk5ICAgICIgZmlsbD0iI0ZGRkZGRiIvPgoJCQk8cG9seWdvbiBwb2ludHM9IjMwMCwyODUuODU1IDE5NC45OTQsMTgwLjg0OSAxODAuODUxLDE5NC45OTEgMjg1Ljg2LDMwMCAyMDMuNDAxLDMwMCAyMDMuNDAxLDMyMCAzMjAsMzIwIDMyMCwyMDMuNDAxICAgICAgMzAwLDIwMy40MDEgICAgIiBmaWxsPSIjRkZGRkZGIi8+CgkJPC9nPgoJPC9nPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+Cjwvc3ZnPgo=";
      fullscreen.style.margin = "0.3em";
      fullscreen.style.height = "75%";
      fullscreen.style["min-height"] = "24px";
      fullscreenUtil.on("click", function() {
        return toggleTargetFullscreen(container);
      }, false);
      util(document).on("webkitfullscreenchange mozfullscreenchange fullscreenchange msfullscreenchange", function() {
        return changeFullscreenState(container);
      });
      controls.appendChild(fullscreen);
      return container.appendChild(controls);
    };
    onWindowResize = function(event) {
      getViewerSize();
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      return renderer.setSize(width, height);
    };
    ref = init(), camera = ref.camera, mesh = ref.mesh, scene = ref.scene, renderer = ref.renderer;
    animate = function() {
      requestAnimationFrame(animate);
      update();
    };
    update = function() {
      updateCamera();
      return renderer.render(scene, camera);
    };
    updateCamera = function() {
      var phi, radius, theta, x, y, z;
      lat = Math.max(-85, Math.min(85, lat));
      phi = THREE.Math.degToRad(90 - lat);
      theta = THREE.Math.degToRad(lon);
      radius = settings.sphere.radius;
      x = radius * Math.sin(phi) * Math.cos(theta);
      y = radius * Math.cos(phi);
      z = radius * Math.sin(phi) * Math.sin(theta);
      return camera.lookAt(new THREE.Vector3(x, y, z));
    };
    animate();
    debugSettings = settings.debug;
    return {
      container: container,
      camera: camera,
      mesh: mesh,
      scene: scene,
      renderer: renderer,
      debugSettings: debugSettings,
      util: util
    };
  };

}).call(this);
